package xyz.will.textcraft;import java.io.BufferedReader;import java.io.InputStreamReader;import java.lang.reflect.Constructor;import java.util.ArrayList;import java.util.HashMap;import java.util.StringTokenizer;import xyz.will.textcraft.command.Command;import xyz.will.textcraft.command.CoordsCommand;import xyz.will.textcraft.command.DigCommand;import xyz.will.textcraft.command.HelpCommand;import xyz.will.textcraft.command.JumpCommand;import xyz.will.textcraft.command.LookCommand;import xyz.will.textcraft.command.PlaceCommand;import xyz.will.textcraft.command.QuitCommand;import xyz.will.textcraft.command.RickrollCommand;import xyz.will.textcraft.command.RunCommand;import xyz.will.textcraft.command.SelectCommand;import xyz.will.textcraft.command.StuffCommand;import xyz.will.textcraft.command.UnknownCommand;import xyz.will.textcraft.command.WalkCommand;/** * Class Parser *  * author: Will Franzen * version: 1.0 * date: Dec 2014 *  * This class takes in strings passed by the user, and converts them to Command objects */public class Parser {	// Map of all the command words where the keys are the words, and the values are the commmand classes    private HashMap<String, Class<? extends Command>> commands;    public Parser() {    	loadCommands();    }    // Read text from the terminal and return a string when a full line is read    public String getCommand() {    	// Instantiate the inputLine variable to hold the line that will be (hopefully) read        String inputLine = "";                // Print an '>' to the terminal        System.out.print("> ");        // Create a BufferedReader to handle data from System.in        BufferedReader reader = new BufferedReader(new InputStreamReader(System.in));                // Attempt to read        try {            inputLine = reader.readLine();        } catch(java.io.IOException exc) { System.out.println ("There was an error during reading: " + exc.getMessage()); }        // Return whatever we've got        return inputLine;    }        // Attempt to parse a string from the user or the command queue to return a Command object    public Command parseCommand(String cmd) {    	// Create tokenizer to read words    	StringTokenizer tokenizer = new StringTokenizer(cmd);            	// First and second word for a command        String word1 = null;        String word2 = null;                // 3rd, 4th, 5th, 6th, 7th, Nth word of a command (used for the 'then' pseudo-command)        ArrayList<String> theRest = new ArrayList<String>();                    // Read 1st and 2nd word        if(tokenizer.hasMoreTokens())        	word1 = tokenizer.nextToken();        if(tokenizer.hasMoreTokens())        	word2 = tokenizer.nextToken();                // If the second word is 'then', shift it to the theRest array        if(word2 != null && word2.equalsIgnoreCase("then")) {        	word2 = null;        	theRest.add("then");        }                // Read in all other words to the theRest array        while(tokenizer.hasMoreTokens())        	theRest.add(tokenizer.nextToken());              // Constructor of the command the user has entered        Constructor<? extends Command> con;        // The command that will be parsed        Command command = null;                   // Attempt to construct a Command from the given strings        // If this fails (because there was no command found), create an instance of UnknownCommand        try {        	// Get the class of the command associated with the given word			Class<? extends Command> cmdClazz = commands.get(word1);			// Get the constructor of that command with a String as it's only argument			con = cmdClazz.getDeclaredConstructor(String.class);			// Set the constructor to accessible        	con.setAccessible(true);		} catch(Exception e) {			try {				// Get the constructor of UnknownCommand				con = UnknownCommand.class.getDeclaredConstructor(String.class);				// Set the constructor to accessible				con.setAccessible(true);			} catch(Exception e2) { con = null; /* This will never happen */ }		}        // Try to create an instance of the Command        try {        	command = con.newInstance(word2);        } catch(Exception e) { /* This will never happen either */ }                // If the word 'then' is at the beginning of the theRest array, remove it        if(theRest.size() > 0 && theRest.get(0).equalsIgnoreCase("then"))        	theRest.remove(0);                // If there are still words left in thw theRest array, join them by spaces and add them        // to the Game's command queue        if(theRest.size() > 0)        	Game.getInstance().queueCommand(StringUtil.join(" ", theRest.toArray(new String[theRest.size()])));                // Return the command created        return command;    }        // Load all of the command classes into the command map    private void loadCommands() {    	commands = new HashMap<String, Class<? extends Command>>();    	    	commands.put("walk",   WalkCommand.class);    	commands.put("run",    RunCommand.class);    	commands.put("help",   HelpCommand.class);    	commands.put("quit",   QuitCommand.class);    	commands.put("coords", CoordsCommand.class);    	commands.put("jump",   JumpCommand.class);    	commands.put("dig",    DigCommand.class);    	commands.put("stuff",  StuffCommand.class);    	commands.put("look",   LookCommand.class);    	commands.put("rick",   RickrollCommand.class);    	commands.put("place",  PlaceCommand.class);    	commands.put("select", SelectCommand.class);    }        // Get a String[] of the keys of the commands map    public String[] getCommandWords() {    	return commands.keySet().toArray(new String[commands.size()]);    }        }